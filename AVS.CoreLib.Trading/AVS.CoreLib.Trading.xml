<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AVS.CoreLib.Trading</name>
    </assembly>
    <members>
        <member name="T:AVS.CoreLib.Trading.Abstractions.IBar">
            <summary>
            represent a bar chart unit (synonym candle or simply bar)  
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.Abstractions.IBar.Volume">
            <summary>
            volume is an amount of base currency
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.Abstractions.IBar.Total">
            <summary>
            total is an amount of quote currency
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.Collections.StringCollection">
            <summary>
            base type to make bind-able string[] parameter type <see cref="T:AVS.CoreLib.Trading.Collections.Exchanges"/>
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Collections.StringCollection.System#Collections#Generic#ICollection{System#String}#Add(System.String)">
            <summary>
            the Add method implemented explicitly due to model binding mechanics 
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.BarSize.Small">
            <summary>
            short bar is a bar with a little price difference between Low and High
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.BarSize.Paranormal">
            <summary>
            Big or paranormal bar is a bar with a significant length several times bigger than average bar
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.CandleType.Doji">
            <summary>
            opens and closes at the same price with bi-directional price fluctuation
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.CandleType.Gravestone">
            <summary>
            open and close at the same price with upper price fluctuation
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.CandleType.Dragonfly">
            <summary>
            open and close at the same price with down price fluctuation
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.CandleType.Whirligig">
            <summary>
            High - Open = Close - Low or High - Close = Open - Low with short body
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.CandleType.HangingMan">
            <summary>
            ohlc.High == ohlc.Open and ohlc.Close - ohlc.Low > body * 2
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.CandleType.InverseHammer">
            <summary>
            ohlc.Low == ohlc.Open and ohlc.High - ohlc.Close > body * 2
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.CandleType.ShootingStar">
            <summary>
            ohlc.Low == ohlc.Close and ohlc.High - ohlc.Open > body * 2
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.OrderCondition.BuyIfAskRise">
            <summary>
            когда мы собираемся войти в рынок в long как только будет преодолена трендовая линия
            но текущая цена ниже чем та по которой мы хотим купить
            к примеру текущая цена 400$ а мы ждем пока преодолеем уровень 500$ 
            и  только тогда затариваемся в лонг
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.OrderCondition.SellIfBidFall">
            <summary>
            когда мы собираемся войти в рынок в short при падении ниже трендовой линии
            но текущая цена пока выше и не понятно будет ли дальнейшее снижение
            например: текущая цена 500$ а мы ждем падения ниже линии до 400$ только тогда открываем шорт
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeInForce.GTC">
            <summary>
            good till cancel
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeInForce.IOC">
            <summary>
            immediate or cancel
            </summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeInForce.FOK">
            <summary>
            Fill or kill
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.Enums.TimeFrame">
            <summary>Represents a time frame of a market.</summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeFrame.M1">
            <summary>A time interval of 1 minute.</summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeFrame.M5">
            <summary>A time interval of 5 minutes.</summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeFrame.M15">
            <summary>A time interval of 15 minutes.</summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeFrame.M30">
            <summary>A time interval of 30 minutes.</summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeFrame.H2">
            <summary>A time interval of 2 hours.</summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeFrame.H4">
            <summary>A time interval of 4 hours.</summary>
        </member>
        <member name="F:AVS.CoreLib.Trading.Enums.TimeFrame.D">
            <summary>A time interval of a day.</summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.DecimalExtensions.Deduct(System.Decimal,System.Decimal)">
            <summary>
            deducts specified percent from the value
            e.g. commission 0.25%, buy 100 xrp in real you will get 100-0.25% = 99.75 xrp 
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.FormatNumberExtensions.FormatPrices(System.Double[],System.String)">
            <summary>
            format numbers to string using n.FormatPrice()
            leading zeros will be replaced by replacement
            (e.g. 0.0001234 => 0..1234) 
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.Extensions.GenericTypeFormatterExtensions">
            <summary>
            GenericFormatter extensions
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.GenericTypeFormatterExtensions.AddTradeTypeFormatter(AVS.CoreLib.Text.Formatters.GenericFormatter.GenericTypeFormatter)">
            <summary>
            Register <see cref="T:AVS.CoreLib.Trading.Enums.TradeType"/> enum formatting
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.GenericTypeFormatterExtensions.AddOrderSideFormatter(AVS.CoreLib.Text.Formatters.GenericFormatter.GenericTypeFormatter)">
            <summary>
            Register <see cref="T:AVS.CoreLib.Trading.Enums.OrderSide"/> enum formatting
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.GenericTypeFormatterExtensions.AddPositionTypeFormatter(AVS.CoreLib.Text.Formatters.GenericFormatter.GenericTypeFormatter)">
            <summary>
            Register <see cref="T:AVS.CoreLib.Trading.Enums.PositionType"/> enum formatting
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.NumberExtensions.GetLeastExpDiff(System.Double,System.Double)">
            <summary>
            Determines the lowest exp for the value so the value*10^exp. > n
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.NumberExtensions.Normalize(System.Double)">
            <summary>
            Rounds value to 8 digits AwayFromZero
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.OhlcExtensions.GetCandleType(AVS.CoreLib.Trading.Abstractions.IOhlc)">
            <summary>
            not implemented to classify all candle types but some basic candle classification is possible
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.OhlcExtensions.GetLength(AVS.CoreLib.Trading.Abstractions.IOhlc)">
            <summary>
            Get candle length in % formula: (High - Low)/Low * 100
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.OhlcExtensions.Contains(AVS.CoreLib.Trading.Abstractions.IOhlc,System.Decimal,System.Boolean)">
            <summary>
            determines whether price is within (Low, High) range;
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.PriceExtensions.GetRoundDecimals(System.Decimal)">
            <summary>
            determines number of meaningful digits based on price value
            </summary>
            <param name="price"></param>
            <returns></returns>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.PriceExtensions.IsAboutTheSame(System.Decimal,System.Decimal,System.Nullable{System.Decimal})">
            <summary>
            compare prices if price difference is tiny returns true (about the same), otherwise false
            when tolerance is not provided, comparison relies on price meaningful digits see <see cref="M:AVS.CoreLib.Trading.Extensions.PriceExtensions.GetRoundDecimals(System.Decimal)"/> 
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.ServiceCollectionExtension.AddTradingCore(Microsoft.Extensions.DependencyInjection.IServiceCollection)">
            <summary>
            Add trading formatters core services
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.Extensions.SymbolExtensions">
            <summary>
            supposed to deal with a normalized symbol like BTC_USDT (i.e. currencies are upper case, underscore separator)  
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.SymbolExtensions.QuoteCurrency(System.String)">
            <summary>
            returns quote currency for BTC_USDT => USDT
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.SymbolExtensions.BaseCurrency(System.String)">
            <summary>
            returns base currency for BTC_USDT => BTC
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.SymbolExtensions.Q(System.String,System.Boolean)">
            <summary>
            returns quote currency, when possible replace currency iso code with symbol e.g. USDT => $
            <seealso cref="M:AVS.CoreLib.Trading.Helpers.CoinHelper.GetCurrencySymbol(System.String)"/>
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.SymbolExtensions.B(System.String)">
            <summary>
            returns base currency for BTC_USDT => BTC
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Extensions.XFormatProviderExtensions.AddTradingFormatters(AVS.CoreLib.Text.FormatProviders.XFormatProvider)">
            <summary>
            Add string formatters
                <see cref="T:AVS.CoreLib.Trading.FormatProviders.PriceFormatter"/>
                <see cref="T:AVS.CoreLib.Trading.FormatProviders.PairStringFormatter"/>
                <see cref="T:AVS.CoreLib.Trading.FormatProviders.OhlcFormatter"/>
                <see cref="T:AVS.CoreLib.Trading.FormatProviders.CurrencySymbolFormatter"/>
            and type formatters for enums:
                <see cref="T:AVS.CoreLib.Trading.Enums.TradeType"/>
                <see cref="T:AVS.CoreLib.Trading.Enums.OrderSide"/>
                <see cref="T:AVS.CoreLib.Trading.Enums.PositionType"/>
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.FormatProviders.CurrencySymbolFormatter.GetQualifiers">
            <summary>
            qualifiers: "$|symbol; i|iso"
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.FormatProviders.OhlcFormatter">
            <summary>
            
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.FormatProviders.OhlcFormatter.GetQualifiers">
            <summary>
            qualifiers: "q|quote; b|base; p|pair; Q|B|symbol"
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.FormatProviders.PairStringFormatter.GetQualifiers">
            <summary>
            qualifiers: "q|quote; b|base; p|pair; Q|B|symbol"
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.FormatProviders.PriceFormattedString">
            <summary>
            takes FormattableString and applies PriceFormatProvider to it => str.ToString(PriceFormatProvider.Instance)
            usage: X.Format($"amount {1.25:a}; price {9.99:price}"); 
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.FormatProviders.PriceFormattedString.op_Implicit(AVS.CoreLib.Trading.FormatProviders.PriceFormattedString)~System.String">
            <summary>
            this is to return PriceFormattedString as a string
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.FormatProviders.PriceFormatter">
            <summary> 
            qualifiers: a|amount; p|price; q|qty|quantity; n|number 
            represents ICustomFormatter implementation (usually it is used by FormatProvider e.g. PriceFormatProvider) 
            usage:
            - string.Format(new PriceFormatProvider(), "amount: {1.25:a}; price: {9.99:price}");
            - X.Format($"amount {1.25:a}; price {9.99:price}"); 
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.FormatProviders.PriceFormatter.GetQualifiers">
            <summary>
            qualifiers: a|amount; p|price; q|qty|quantity; n|number; t|total
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.FormatProviders.PriceFormatter.CustomFormat(System.String,System.Object,System.IFormatProvider)">
            <summary>
            format double/decimal argument to string
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.FormatProviders.T.FormatProvider">
            <summary>
            Include formatters: PriceFormatter, PairStringFormatter, TradingEnumsFormatter, CurrencySymbolFormatter
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.FormatProviders.T.Format(System.FormattableString)">
             <summary>
             Format string with <see cref="P:AVS.CoreLib.Trading.FormatProviders.T.FormatProvider"/> matching trading formatters
             
             PriceFormatter qualifiers:
                 a|amount - FormatNumber(default) [3-4 decimals];
                 p|price - FormatAsPrice();
                 q|qty|quantity - FormatNumber(3)
                 t|total - FormatNumber(2)
                 N|normalized - 0.######## [PrecisionDigits]
            
             PairString qualifiers:
               q|quote - quote currency;
               b|base - base currency;
               p|pair - currency pair;
               Q - quote currency symbol
               B|$ - base currency symbol
             
             TradingEnums qualifiers:
                 `+` - +/-;
                 c|character - buy/sell;
                 n|number - int value
             
             CurrencySymbol qualifiers:
                 $|symbol - currency symbol;
                 i|iso - iso code;
             </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.FormatProviders.TradingEnumsFormatter">
            <summary>
            This formatter is replaced with <see cref="!:CompositeFormatter"/>
            formatter for TradeType, OrderSide, PositionType enums
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.FormatProviders.TradingEnumsFormatter.GetQualifiers">
            <summary>
            qualifiers: +; c|character; n|number
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.FormatProviders.TradingFormatter">
            <summary>
            Combines a set of custom trading formatters such as
            <see cref="T:AVS.CoreLib.Trading.FormatProviders.CurrencySymbolFormatter"/>
            <see cref="T:AVS.CoreLib.Trading.FormatProviders.PriceFormatter"/>
            <see cref="T:AVS.CoreLib.Trading.FormatProviders.PairStringFormatter"/>
            <see cref="T:AVS.CoreLib.Trading.FormatProviders.OhlcFormatter"/>
            used by X.Format util <seealso cref="T:AVS.CoreLib.Text.FormatProviders.XFormatProvider"/>
            TradingFormatter is registered by <see cref="M:AVS.CoreLib.Trading.Extensions.ServiceCollectionExtension.AddTradingCore(Microsoft.Extensions.DependencyInjection.IServiceCollection)"/>
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Helpers.IRankHelper.GetRank(System.Decimal,System.String)">
            <summary>
            estimates trade total rank
            was it a micro trade or a large one
            the greater rank the larger the trade was
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.Models.Balance.BalanceBook.Count">
            <summary>
            Gets the number of currencies in balance book 
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Models.Balance.BalanceBook.Parse(System.String)">
            <summary>
            Can parse BalanceBook from strings like "0.2 BTC;10 USD; 25 TRX;0.05 ETH" 
            </summary>
        </member>
        <member name="P:AVS.CoreLib.Trading.Prices.PriceHelper.Prices">
            <summary>
            these are indicative prices for purposes like ranking coins by value relative to other coins
            indicative means for example BTC is ~10 times bigger than ETH or ~100 times bigger than BCH, LTC etc. 
            </summary>
        </member>
        <member name="T:AVS.CoreLib.Trading.Types.CurrencyPair">
            <summary>
            in `BTC_USDT`, BTC is a base currency, USDT is a quote currency
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Types.CurrencyPair.Parse(System.String,System.Boolean)">
            <summary>
            Parse <see cref="T:AVS.CoreLib.Trading.Types.CurrencyPair"/> instance from symbol/pair string
            </summary>
            <param name="value">symbols like `BTC_USDT` or pairs like 'BTC/USDT' </param>
            <param name="isBaseCurrencyFirst">base currency in `BTC_USDT` is BTC</param>
        </member>
        <member name="T:AVS.CoreLib.Trading.Types.CurrencyValue">
            <summary>
            Represents values like 10.00 UAH, 2.2 XRP etc.
            </summary>
        </member>
        <member name="M:AVS.CoreLib.Trading.Types.CurrencyValue.Parse(System.String)">
            <summary>
            parses string for the value
            </summary>
            <param name="str">"100.00 UAH"</param>
        </member>
        <member name="T:AVS.CoreLib.Trading.Types.Symbol">
            <summary>
            Symbol represent a trade instrument, most exchanges operate symbols 
            <see cref="T:AVS.CoreLib.Trading.Types.Symbol"/> format convention is [base_currency]_[quote_currency] e.g. BTC_USDT
            </summary>
            <remarks>
            this type replace <see cref="!:PairString"/>  pair `USDT_BTC` pair is a `BTC_USDT` symbol, i.e. swap quote and base currencies 
            </remarks>
        </member>
        <member name="T:AVS.CoreLib.Trading.Types.Symbols">
            <summary>
            type to deal with a collection of symbols (trading instrument) <see cref="T:AVS.CoreLib.Trading.Types.Symbol"/>   
            </summary>
        </member>
    </members>
</doc>
